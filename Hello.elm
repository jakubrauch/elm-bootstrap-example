{-
There is a terrific guide and tutorial to Elm on:
 - https://guide.elm-lang.org
 - https://www.elm-tutorial.org/en/

Generally those are the best starting points for your adventure with Elm. Whenever you feel confused by the notes below
to give the full tutorial a try. -}


-- MODULE
-- definition of the module we create (module name must correspond to file name and its location)
module Hello exposing (..)

-- IMPORTS
-- all dependencies that are required for our program (here it will be mainly Html and its dependencies).
import Html exposing (Html, Attribute, div, a, text, input, button, span, p, h1, node, program)
import Html.Events exposing (onClick, onInput)
import Html.Attributes exposing (..)

{-
A standard Elm program is composed of three parts: model, update, view. In very general terms:
 - Model is a (potentially large) structure holding entire application state.
 - Messages are actions/events passed within application to indicate a change to the Model
 - Update is responsible for transforming the model state based on given Message
 - View is responsible for building an html page based on the output model generated by the update function.

In addition to the above we have the following:
 - Main - program main entry that wires up all the above together (plus Cmd and Sub that we do not use in our example):
   - init: Model (+ Cmd) - model (plus a command, more on that below).
   - update: Update
   - view: View
   - (subscriptions: Sub - more on that below)
For reference - the actual program signature is as follows:
program
  : { init : (model, Cmd msg)
    , update : msg -> model -> (model, Cmd msg)
    , view : model -> Node msg
    , subscriptions : model -> Sub msg
    }
  -> Program Never model msg

Last but not least there are tools for interacting with external world (we will not use it in our example):
 - Cmd - commands that will have side effects (remote request, random number generation, persisting data)
 - Sub - subscriptions to external events (response from remote server, mouse clicks, key presses)

-}


-- MODEL
type alias Model = { items: List Item, newItem: String }
type alias Item = String

init : ( Model, Cmd (Msg a) ) {- Our initial state of the app includes both model and a command (latter not used). -}
init = ({ items = ["first", "second"]
        , newItem = ""
        }, Cmd.none)

-- MESSAGES
-- Let's define list of events that can happen in the application
type Msg a = ChangeText a | AddItem a | RemoveItem a

-- VIEW
-- Converts given model to html and potentially produces Html-tagged message TODO
-- Note: Mind the verbosity of the below code. Most of it is the bootstrap complexity. Moreover this could be easily
-- simplified using named functions but I wanted to present the complete view hierarchy.
view : Model -> Html (Msg Item)
view model =
    div []
        [ node "link" [ (href "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"), (rel "stylesheet") ] []
        , node "link" [ (href "style.css"), (rel "stylesheet"), (type_ "text/css") ] []
        , node "link" [ (href "https://fonts.googleapis.com/css?family=Open+Sans|Roboto"), rel ("stylesheet") ] []
        , div [ class "container-fluid" ] [
            div [ class "row" ]
              [ div [ class "col-xs-12 bg-primary" ]
                  [ h1 [] [ text "Elm Bootstrap Task List" ] ]
              ]
            ]
        , div [ class "container" ]
            [ div [ class "body" ]
                (div [ class "row" ] -- new item row
                    [ div [ class "col-xs-12 col-sm-offset-3 col-sm-6" ]
                        [ div [ class "input-group" ]
                            [ input [ value model.newItem, onInput ChangeText, class "form-control", placeholder "Item" ] []
                            , span [ class "input-group-btn" ]
                                [ button [class "btn btn-primary", onClick (AddItem model.newItem)]
                                    [ span [ class "glyphicon glyphicon-plus" ] [] ]
                                ]
                            ]
                        ]
                    ]
                 ::
                List.map -- list of existing items
                    ( \m -> div [ class "row" ] [
                        div [ class "col-xs-12 col-sm-offset-3 col-sm-6" ]
                            [ div [ class "item" ] [
                                span [] [ text m ]
                                , button [ class "btn btn-danger text-right", onClick (RemoveItem m) ]
                                    [ span [ class "glyphicon glyphicon-remove" ] [] ]
                                ]
                            ]
                        ]
                    )
                    model.items
                )
            ]
        , div [ class "footer color-invert" ]
            [ div []
                [ a [ href "https://www.github.com/jakubrauch/elm-bootstrap-example" ] [ span [] [ text "https://github.com/jakubrauch/elm-bootstrap-example" ] ] ]
            ]
        ]


-- UPDATE
-- Applies the given Msg to the Model (+ may generate some side-effects using Cmd but we don't have any in our example)
update : Msg String -> Model -> (Model, Cmd (Msg String))
update msg model =
    case msg of
        ChangeText i -> ( { model | newItem = i }, Cmd.none) -- Cmd: TODO
        RemoveItem i -> ( { model | items = List.filter ((/=)i) model.items }, Cmd.none )
        AddItem i -> -- only add items that do not exist in the list yet
            if List.isEmpty (List.filter ((==)i) model.items) then
                ( { model | items = model.newItem :: model.items, newItem = "" }, Cmd.none )
            else
                ( model, Cmd.none )

-- SUBSCRIPTIONS
-- Defines subscriptions to external events (we do not have any in our example)
subscriptions : Model -> Sub (Msg a)
subscriptions model = Sub.none

-- MAIN
-- Wires all up.
main : Program Never Model (Msg Item)
main =
    program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
    }
