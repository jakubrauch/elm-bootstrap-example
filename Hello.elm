module Hello exposing (..)

{- A standard Elm program is composed of three parts: model, update, view. In very general terms:

Model is a pair of:
 - a big tree holding application state
 - a message (action) that should be applied on the current state (can be no-op if nothing is happening)

Update is responsible for transforming the model's application state depending on what message is defined in the model.

View is responsible for building an html page based on the model generated by the update function.

Typically in Elm the main HTML-based program is structured as follows:
 - MODULE - definition of the module we create (module name must correspond to file name and its location)
 - IMPORTS - all dependencies that are required for our program (here it will be mainly Html and its dependencies).
 - MODEL - current state of the app, immutable structure of whatever data you want your page to be fed with,
 - MESSAGES - actions that happen in our application and to which or application reacts,
 - VIEW - renders HTML elements,
 - UPDATE - function that is called whenever program receives a message, it updates model and returns command as needed,
 - SUBSCRIPTIONS - listening to external events like mouse movements, key presses, page location changes,
 - MAIN - entry point of the program, main function.
(see https://www.elm-tutorial.org/en/ for more details)
-}

{- IMPORTS -}
import Html exposing (Html, div, text, p, program)

{- MODEL -}
type alias Model = List String

init : ( Model, Cmd (Msg a) ) {- Our initial state of the app includes both model and a command -}
init = (["first", "second"], Cmd.none)

{- MESSAGES -}
type Msg a = NoOp | Add a | Remove a

{- VIEW -}
view : Model -> Html (Msg a) {- Converts given model to html and produces messages tagged with Msg TODO: ??? -}
view model =
    div [] (List.map
        (\m -> p [] [text m])
        model)

{- UPDATE -}
update : Msg a -> Model -> (Model, Cmd (Msg a))
update msg model =
    case msg of
        NoOp -> ( model, Cmd.none )
        _ -> ( model, Cmd.none ) {- So far we do nothing for other cases -}

{- SUBSCRIPTIONS -}
subscriptions : Model -> Sub (Msg a)
subscriptions model = Sub.none {- No subscriptions for the moment, but you can handle mouse/keyboard later -}

{- MAIN -}
{- Program's signature:
program
  : { init : (model, Cmd msg)
    , update : msg -> model -> (model, Cmd msg)
    , subscriptions : model -> Sub msg
    , view : model -> Node msg
    }
  -> Program Never model msg
-}
main : Program Never Model (Msg a)
main =
    program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
    }
