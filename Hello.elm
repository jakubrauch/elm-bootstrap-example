{- There is a terrific guide and tutorial to Elm on:
 - https://guide.elm-lang.org
 - https://www.elm-tutorial.org/en/
Generally those are the best starting points for your adventure with Elm. Whenever you feel confused by the notes below
to give the full tutorial a try. -}


-- MODULE
-- definition of the module we create (module name must correspond to file name and its location)
module Hello exposing (..)

-- IMPORTS
-- all dependencies that are required for our program (here it will be mainly Html and its dependencies).
import Html exposing (Html, Attribute, div, text, input, button, p, node, program)
import Html.Events exposing (onClick, onInput)
import Html.Attributes exposing (..)

{-
A standard Elm program is composed of three parts: model, update, view. In very general terms:
 - Model is a (potentially large) structure holding entire application state.
 - Update is responsible for transforming the application state based on given "message" (we'll come to that in a sec)
 - View is responsible for building an html page based on the model generated by the update function.

In addition to the above we have the following:
 - Messages - actions/events that change state of the application.
 - Subscriptions - listeners on external events like mouse movements, key presses, etc.
 - Main - program main entry that wires up all the above together:
   - init: Model + Cmd(Message) - model together with what should be done with it (message).
   - view: View
   - update: Update
   - subscriptions: Subscriptions

For reference - the actual program signature is as follows:
program
  : { init : (model, Cmd msg)
    , update : msg -> model -> (model, Cmd msg)
    , subscriptions : model -> Sub msg
    , view : model -> Node msg
    }
  -> Program Never model msg
-}


-- MODEL
type alias Model = { items: List Item, newItem: String }
type alias Item = String

init : ( Model, Cmd (Msg a) ) {- Our initial state of the app includes both model and a command -}
init = ({ items = ["first", "second"]
        , newItem = ""
        }, Cmd.none)

-- MESSAGES
-- Let's define list of events that can happen in the application
type Msg a = NoOp | Change a | Add a | Remove a

-- VIEW
-- Converts model to Html page
view : Model -> Html (Msg Item) {- Converts given model to html and produces messages tagged with Msg TODO -}
view model =
    div [ class "container" ] [
        stylesheet "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css",
        div [ class "row" ] [
            div [ class "col-xs-12 col-sm-offset-3 col-sm-6"] (
                (List.map(\m -> p [] [text m, button [class "btn btn-danger", onClick (Remove m)] [text "remove"]]) model.items) ++
                [ input [onInput Change] []
                , button [class "btn btn-primary", onClick (Add model.newItem)] [text "add"]
                ]
            )
        ]
    ]
-- Stylesheet only for generating link to bootstrap
stylesheet : String -> Html msg
stylesheet loc=
    node "link" [ (href loc), (rel "stylesheet"), (type_ "text/css") ] []

-- UPDATE
-- Applies the given Msg to the Model
update : Msg String -> Model -> (Model, Cmd (Msg String))
update msg model =
    case msg of
        NoOp -> ( model, Cmd.none )
        Change i -> ( { model | newItem = i }, Cmd.none) -- Cmd: TODO
        Add i -> ( { model | items = model.newItem :: model.items, newItem = "" }, Cmd.none)
        Remove i -> ( { model | items = List.filter ((/=)i) model.items }, Cmd.none)

-- SUBSCRIPTIONS
-- No subscriptions for the moment, but you can handle mouse/keyboard later
subscriptions : Model -> Sub (Msg a)
subscriptions model = Sub.none

-- MAIN
-- Wires all up.
{- Program's signature:
program
  : { init : (model, Cmd msg)
    , update : msg -> model -> (model, Cmd msg)
    , subscriptions : model -> Sub msg
    , view : model -> Node msg
    }
  -> Program Never model msg
-}
main : Program Never Model (Msg Item)
main =
    program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
    }
