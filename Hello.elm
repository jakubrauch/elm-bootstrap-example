{- There is a terrific guide and tutorial to Elm on:
 - https://guide.elm-lang.org
 - https://www.elm-tutorial.org/en/
Generally those are the best starting points for your adventure with Elm. Whenever you feel confused by the notes below
to give the full tutorial a try. -}


-- MODULE
-- definition of the module we create (module name must correspond to file name and its location)
module Hello exposing (..)

-- IMPORTS
-- all dependencies that are required for our program (here it will be mainly Html and its dependencies).
import Html exposing (Html, div, text, input, button, p, program)
import Html.Events exposing (onClick, onInput)

{-
A standard Elm program is composed of three parts: model, update, view. In very general terms:
 - Model is a (potentially large) structure holding entire application state.
 - Update is responsible for transforming the application state based on given "message" (we'll come to that in a sec)
 - View is responsible for building an html page based on the model generated by the update function.

In addition to the above we have the following:
 - Messages - actions/events that change state of the application.
 - Subscriptions - listeners on external events like mouse movements, key presses, etc.
 - Main - program main entry that wires up all the above together:
   - init: Model + Cmd(Message) - model together with what should be done with it (message).
   - view: View
   - update: Update
   - subscriptions: Subscriptions

For reference - the actual program signature is as follows:
program
  : { init : (model, Cmd msg)
    , update : msg -> model -> (model, Cmd msg)
    , subscriptions : model -> Sub msg
    , view : model -> Node msg
    }
  -> Program Never model msg
-}


-- MODEL
type alias Model = { items: List Item, newItem: String }
type alias Item = String

init : ( Model, Cmd (Msg a) ) {- Our initial state of the app includes both model and a command -}
init = ({ items = ["first", "second"]
        , newItem = ""
        }, Cmd.none)

-- MESSAGES
type Msg a = NoOp | Change a | Add a | Remove a

-- VIEW
view : Model -> Html (Msg Item) {- Converts given model to html and produces messages tagged with Msg TODO -}
view model =
    div [] ((List.map(\m -> p [] [text m, button [onClick (Remove m)] [text "remove"]]) model.items) ++
        [ input [onInput Change] []
        , button [onClick (Add model.newItem)] [text "add"]
        ])

-- UPDATE
update : Msg String -> Model -> (Model, Cmd (Msg String))
update msg model =
    case msg of
        NoOp -> ( model, Cmd.none )
        Change i -> ( { model | newItem = i }, Cmd.none) -- TODO
        Add i -> ( { model | items = model.newItem :: model.items, newItem = "" }, Cmd.none)
        Remove i -> ( { model | items = List.filter ((/=)i) model.items }, Cmd.none) {- So far we do nothing for other cases -}

-- SUBSCRIPTIONS
subscriptions : Model -> Sub (Msg a)
subscriptions model = Sub.none {- No subscriptions for the moment, but you can handle mouse/keyboard later -}

-- MAIN
{- Program's signature:
program
  : { init : (model, Cmd msg)
    , update : msg -> model -> (model, Cmd msg)
    , subscriptions : model -> Sub msg
    , view : model -> Node msg
    }
  -> Program Never model msg
-}
main : Program Never Model (Msg Item)
main =
    program
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
    }
